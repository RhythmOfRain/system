 我们写过很多C程序了，经常会分配内存。记得刚学C语言时老师说过，可以向两个地方申请内存：一个是栈、一个是堆。小块内存向栈申请，函数调用结束后程序会自动释放内存。大块内存向堆申请，记得一定要自己释放，否则会造成内存泄漏。向堆申请内存直接调用malloc()就可以了，参数是你申请的内存量。释放内存时直接调用free()就可以了，参数是内存块指针。
        看似平静的海面，海底则波涛汹涌。当时还没有学操作系统原理，更没有读过Linux内核代码。现在仔细想想才发现申请动态内存是一件多么麻烦的事情。动态内存管理涉及到两个层面的问题：内核层面和用户层面。系统中的内存如何管理这是内核考虑的事情，总不能让应用程序随便使用系统中的内存吧。内核向应用程序提供了接口（为此Linux提供了两个系统调用brk和mmap），当应用程序需要申请内存时向内核提出请求，内核查找并分配一块可用内存供应用程序使用。这部分内容属于内核范畴，不属于C基础库，因此不深入说了。那么用户层面做什么呢？用户层面需要合理管理内存申请和释放请求。比如：brk()可以扩充或收缩堆的大小，你总不能每分配一次内存就调用一次brk()吧？释放内存时更麻烦，你必须保证内存块的释放顺序。比如先申请了内存块a，然后申请了内存块b，然后释放a（b仍然在使用），如果释放a时调用了brk()就会出问题。你不能在使用b的同时释放a。
        好在出现了一个叫做“内存分配器”的东西，内存分配器接管了应用程序申请内存和释放内存的请求，应用程序再也不需要直接调用brk()和mmap()了，而是向内存分配器提交申请。有了内存分配器，我们只需要记住malloc()和free()两个接口函数就可以了，其他繁琐事情全部交给内存分配器负责了。申请内存时，内存分配器会一次向内核申请大量内存，然后分批交给应用程序，从而提高了效率。释放内存时，应用程序也是将内存释放给内存分配器，内存分配器在合适的时候再将内存释放会内核。
        dlmalloc就是一种内存分配器，由Doug Lea在1987年开发完成，这是Android系统中使用的内存分配器。而Linux系统中采用的是ptmalloc，ptmalloc在dlmalloc的基础上进行了改进，以更好适应多线程。dlmalloc采用两种方式申请内存，如果应用程序单次申请的内存量小于256kb，dlmalloc调用brk()扩展进程堆空间，但是dlmalloc向内核申请的内存量大于应用程序申请的内存量，申请到内存后dlmalloc将内存分成两块，一块返回给应用程序，另一块作为空闲内存先保留起来。下次应用程序申请内存时dlmalloc就不需要向内核申请内存了，从而加快内存分配效率。当应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。

linux采用的是glibc中堆内存管理ptmalloc实现，虚拟内存的布局规定了malloc申请位置以及大小，malloc一次性能申请小内存（小于128KB），分配的是在堆区（heap），用sbrk()进行对齐生长，而malloc一次性申请大内存（大于128KB时）分配到的是在映射区，而不是在堆区，采用的mmap()系统调用进行映射。

http://blog.csdn.net/ycnian/article/details/12971863